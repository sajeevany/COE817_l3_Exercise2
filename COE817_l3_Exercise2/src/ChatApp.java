package chatapp;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

//
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Scanner;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;

public class ChatApp implements Runnable{
	
	public enum designation{server, client};
	
	private String hostToConnect, alias;
	private int port, myPublicKey, myPrivateKey, mySessionKey;
	private ServerSocket sSocket;
	private DataOutputStream dataOutStream;
	private DataInputStream dataInStream;
	designation myDesignation;
	Thread cThread;
	
	/*
	 * Generates ChatClient object.
	 * 
	 * @hostToConnect - host to connect to. This is used by both server/client
	 * @portToConnect - port on which to open/connect socket
	 * @myAlias - Alias to be used in chat. If undefined, default will be used.
	 * @keyGenerationSeed - Seed used to generate secret key. If null random value will be assigned.
	 * @mydesignation - Designation indicates ChatApp behaviour. Dictates type server or type client
	 */
	public ChatApp (String hostToConnect, int portToConnect, String myAlias, String keyGenerationSeed, designation mydesignation)
	{
		if (hostToConnect == null || Integer.toString(portToConnect) == null || mydesignation == null)
		{
			throw new IllegalArgumentException("Input values are invalid");
		}
		this.hostToConnect = hostToConnect;
		this.port = portToConnect;
		this.alias = (myAlias == null) ? "defaultName" : myAlias;
		this.myDesignation = mydesignation;
		
		//generate public/private keys
		
		//run designation-specific initialization methods
		try {
			switch(myDesignation)
			{
				case server:
					openPort();
					break;
				case client:
					break;
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void openPort() throws IOException
	{
		sSocket = new ServerSocket(port);
		sSocket.setSoTimeout(10000);		
	}
	
	public void start ()
	{
		System.out.println("Starting " + myDesignation.toString());
		if (cThread == null)
		{
			cThread = new Thread (this, myDesignation.toString()  + "_" + port);
			cThread.start ();
		}
    }
	
	public void run()
	{
		Socket mySocket;
		
		//start GUI/UI
				
		
		try {
			while(true)
			{
				if (this.myDesignation == this.myDesignation.server)
				{
					mySocket = sSocket.accept();
				} 
				else
				{
					mySocket =  new Socket(this.hostToConnect, this.port);
				}
				dataOutStream = new DataOutputStream(mySocket.getOutputStream());
				dataInStream = new DataInputStream(mySocket.getInputStream());
				
				//Wait for connection/open connection
				//Handshake
					//exchange public keys
					//3 stage handshake
				
				//wait for action and act on action
					//sign message with private key of local app
					//encrypt message with public key of target client
			}
		}catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
        
        //desKeygen() returns a Secret Key Object, need to be used to encrypt and decrypt
        // encryptMessage takes in string and returns a Byte array
        // decryptMessage takes byte array and returns Original string
        // Nounce values must be equal for encrypt and decrypt.. OR ELSE computer will explode
        
        // EXAMPLE USE 
           // byte nounce = 1;
           // SecretKey newKey = desKeyGen();
           // byte[]encryptedMessage =  encryptDES(message , nounce, newKey);
          //  String output = decryptDES(encryptedMessage , nounce, newKey);

        
        public SecretKey desKeyGen() throws NoSuchAlgorithmException {

         //init keygenerator, Object contains functionality to create keys
         KeyGenerator keygen = KeyGenerator.getInstance("DES");
         // generate key
         SecretKey DESkey = keygen.generateKey();

         return DESkey;
        }
        //Pass in a message, nounce and key(Key must be generated by deskeyGen )
        // Returns a BYTE array, the byte array is concatenated with a Nounce 
        public byte[] encryptDES(String message, byte nounce, SecretKey key) {

         try {


          //Cipher object contains Cryptographic cipher functionality
          Cipher desObject;
          // Specify Cipher params
          // DES, ECB Electronic Codebook mode, PKCS5Padding means With Padding, 
          desObject = Cipher.getInstance("DES/ECB/PKCS5Padding");

          //convert message to byte array, Cipher Methods take Byte Arrays as parameters

          byte[] messageBytes = message.getBytes();
          messageBytes[messageBytes.length] = nounce;
          //init cipher encrpyt more with Generated key
          desObject.init(Cipher.ENCRYPT_MODE, key);
          // doFinal runs multi part Encryption 
          byte[] bytesEncrypted = desObject.doFinal(messageBytes);
          return bytesEncrypted;


         } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {

          System.out.println(e);
          return null;
         }


        }

        // Nounce value must be equal to that of the message 
        // this method returns a String
        public String decryptDES(byte[] encryptedMessage, int currentNounce, SecretKey key) {

         try {
          //Cipher object contains Cryptographic cipher functionality
          Cipher desObject;
          // Specify Cipher params
          // DES, ECB Electronic Codebook mode, PKCS5Padding means With Padding, 
          desObject = Cipher.getInstance("DES/ECB/PKCS5Padding");

          // init and execute Decypher mode, using same key
          desObject.init(Cipher.DECRYPT_MODE, key);
          byte[] bytesDecrypted = desObject.doFinal(encryptedMessage);

          if (bytesDecrypted[bytesDecrypted.length - 1] != currentNounce) {
           System.out.println("BAD NOUNCE");
           return null;
          } else {
           Arrays.copyOf(bytesDecrypted, bytesDecrypted.length - 1);
           // Converts Bytes to output string
           String outputText = new String(bytesDecrypted, "UTF-8");
           return outputText;
          }

         } catch (NoSuchAlgorithmException | UnsupportedEncodingException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {

          System.out.println(e);
          return null;
         }


        }
}
